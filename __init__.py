# t = threading.Thread()
# t.run(): 用以表示线程活动的方法
# t.start(): 启动线程活动
# t.isAlive(): 返回线程是都活动的
# t.getName(): 返回线程名
# t.setName(): 设置线程名
# threading模块提供的一些方法
# threading.currentThread(): 返回当前线程的变量
# threading.enumerate(): 返回一个包含正在运行的线程的list,正在运行指线程启动后,结束前
# threading.activeCount(): 返回正在运行的线程数量,与len(threading.enumerate())一致


# 同步锁: 保证多个线程的数据一致性
# 线程死锁和递归锁: 线程死锁,当有两把锁是,线程想占有对象的锁时,
#                 两个线程不会主动释放,一直在僵持,就会造成死锁
#                使用递归锁进行解除死锁, 递归锁内部有计数器来记录锁的数量
# 同步对象和信号量: 见threading_lock.py
# 线程队列 -------> 生产者消费者模型: 见threading_lock.py
# 进程: 见processes.py


# 并发 & 并行
# 并发: 是指系统具有处理多个任务(动作)的能力
# 并行: 是指系统具有同时处理多个任务(动作)的能力
# 并行是不是并发的一个子集

# 同步与异步
# 同步: 当进程执行到一个IO操作(等待外部数据)的时候就是同步的程序
# 异步: 当进程执行到一个IO操作时, 不阻塞等待, 等到数据接收成功在回来处理

# 问题: 多核没有使用上
# GIL: global explain lock(全局解释锁)
# 因为有GIL, 所以, 同一时刻只有一个线程被执行
# 无论有多少个线程, Python在执行的时候会在用一时刻只允许一个线程运行(解释器)
# 为什么不让多个线程同时执行

# 计算密集型: Python的多线程就不推荐,可以采用多进程 + 协程
# IO密集型: Python的多线程是有意义的


#####################################################
# 协程: 协助式 --- 非抢占式
# yield协程关键字
# 用户态的切换
# 什么时候切换 !
# 协程主要解决的也是IO操作
# 协程本质上就是一个线程
